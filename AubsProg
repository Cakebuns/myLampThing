#include <FastLED.h>
#define NUM_LEDS 84
#define DATA_PIN 3
#define WAVELENGTH 125 // # of steps peak-to-peak 
#define MAXBRIGHT 255  // maximum brightness level (min is 0)
#define DELAY_MS 50   // delay before updating colors, in ms
#define SCALING_FACTOR 20 //THe phase distance in waveform between the each LED

class ButtCheck {


  public:           // Access specifier
    unsigned long buttonStartTime = 0; //Start time since the button has been high, with debounce control
    unsigned long lastTimeCheck = 0;
    int debCount; //debounce buffer counter.  zero = button is off
    const int debBufferMax = 50; //button has to be low for at least 50 ms to be registered as off
    const int timeCheckInterval = 1; //
    int myButtonPinNum; //what button pin number is it that I'm watching 
    
    ButtCheck(int tempButt) {     // Constructor
      myButtonPinNum = tempButt;
    }

    int timeButtPush() {
      
      unsigned long currTimeCheck = millis();  //temp var to get current time
      //if sufficient time has passed since the last time check
      if (currTimeCheck - lastTimeCheck >= timeCheckInterval) {
        lastTimeCheck = currTimeCheck;
        //if button is pushed
        if (digitalRead(myButtonPinNum)) { //if reads button as high
          if (debCount == 0) { //first signal that the button has been pushed.  So, set the start time as now
            buttonStartTime = currTimeCheck;
          }
          debCount = debCount + 10;
          
          if (debCount > debBufferMax) {
            debCount = debBufferMax;
          } 
        } else { //if reads button as low
          debCount = debCount - 1;
        }
      }
      if (debCount <= 0) {//debounce buffer has run out, so assume button was actually released
        debCount = 0;
        return 0;
      }
      int tempInt = currTimeCheck - buttonStartTime;
      return tempInt;
    }

};

/*
  we're going to use a triangle wave that's truncated below 0, like so:
  MAX |\                  /\
      | \                /  \
      |  \              /    \
      |   \            /      \
  0___|____\__________/________\_
      |

  but then overlay 3 of these, one each for R, G, B:
      R    G    B         R    G
  MAX |\   /\   /\  oops  /\   /\
      | \ /  \ /  \      /  \ /
      |  X    X    \    /    X
      | / \  / \    \  /    / \
  0___|/___\/___\____\/____/___\_
      |

  so really we want to cut off half of the negative (zero) part of the cycle:
  MAX |\             /\
      | \           /  \
      |  \         /    \
      |   \       /      \
  0___|____\_____/________\_
      |

  for this pattern:
      R    G    B    R    G    B
  MAX |\   /\   /\   /\   /\   /\
      | \ /  \ /  \ /  \ /  \ /
      |  X    X    X    X    X
      | / \  / \  / \  / \  / \
  0___|/___\/___\/___\/___\/___\/_
      |

  so, using WAVELENGTH and MAXBRIGHT, we precalculate an array of values sampled
  from the conceptual (dis)continuous function, then shift along those at each
  step, with a different offset for each color
*/

CRGB leds[NUM_LEDS];
int Ridx;
int Gidx;
int Bidx;
int tempRidx;
int tempGidx;
int tempBidx;

unsigned long prevMsL = 0;

const int buttonPin = 8;  // the number of the pushbutton pin
ButtCheck myTouchSense(buttonPin);

bool lightsOn = 1; //default on
bool redMode = 0; //default off
int buttPressedTime; 

byte waveform[WAVELENGTH];


void setup() {
  pinMode(buttonPin, INPUT);
  Serial.begin(9600);
  Serial.println("Hi");
  FastLED.addLeds<WS2811, DATA_PIN>(leds, NUM_LEDS);



  
  // TODO: delete most of this code by using the FastLED triwave8() func
  //       also look into other provided funcs
  //       (maybe beatsin8 would be even better?)

  /*
    start moving upward from the wave minimum, so we're going to generate this:
    MAX |     /\
        |    /  \
    0___|___/____\_
  */

  double slope = (double) (MAXBRIGHT) / (WAVELENGTH / 3);
  double val = -1 * MAXBRIGHT;
  //Serial.print("slope = "); Serial.println(slope);
  for (int i=0; i < WAVELENGTH; i++) {
    // TODO: probably going to be some errors in here
    // wrt int -> double -> int conversion
    
    // clamp to 0 while val is negative
    if (val >= 0) {
      waveform[i] = floor(val);
    } else {
      waveform[i] = 0;
    }

    val = val + slope;

    // once we hit max, start going down
    if (val >= MAXBRIGHT) {
      val = MAXBRIGHT;
      slope *= -1;
    }
    //Serial.print("i: "); Serial.print(i); Serial.print(" = "); Serial.println(val);
  }
  // these offsets will make the cycle start at 100% red,
  // as in the diagram above
  Ridx = (2 * WAVELENGTH) / 3;
  Gidx = WAVELENGTH / 3;
  Bidx = 0;
}

void loop() {
  if (lightsOn) {
    lightsCycle();
  }

  if (buttPressedTime > 0 && myTouchSense.timeButtPush() == 0) { //button released functions
    if (buttPressedTime > 500 && buttPressedTime < 3000) { //power off if released for between 1 and 2 secs
      lightsOn = !lightsOn;
      if (!lightsOn) {
        lightsOff();
      }
    }
    if (buttPressedTime > 3000) { //switch modes if released for longer than 3 secs
      redMode = !redMode;
    }
  }

/*
  if (buttPressedTime > 3000 && scPowerOff == 0) {//first state change

    
  }

  if (buttPressedTime == 0) {//reset all the state change bools

  }
  */
 
  buttPressedTime = myTouchSense.timeButtPush();
}

void lightsOff() {
  for (int i = 0; i < NUM_LEDS; i++) {
      leds[i].setRGB(0,0,0);
  }
 
  FastLED.show();
}

void lightsCycle() {
  

    unsigned long currTime = millis();
    if (currTime - prevMsL > DELAY_MS) {  //Only do the lightcycle if enough time has passed
      prevMsL = currTime;
      for(int n=0; n < NUM_LEDS; n++) {
        // scan through the full waveform to assign a different value
        // to each LED, looping back to the start as necessary, separating them out by the scaling factor
        tempRidx = (Ridx + n*SCALING_FACTOR) % WAVELENGTH;
        tempGidx = (Gidx + n*SCALING_FACTOR) % WAVELENGTH;
        tempBidx = (Bidx + n*SCALING_FACTOR) % WAVELENGTH;
        leds[n].r = waveform[tempRidx];
        leds[n].g = waveform[tempGidx];
        if (redMode) {
          leds[n].b = 0;
        } else {
          leds[n].b = waveform[tempBidx];
        }
      }

      Ridx = (Ridx + 1) % WAVELENGTH;
      Gidx = (Gidx + 1) % WAVELENGTH;
      Bidx = (Bidx + 1) % WAVELENGTH;
      FastLED.show();
  }
}

