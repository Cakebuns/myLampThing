#include <FastLED.h>
#define NUM_LEDS 84
#define DATA_PIN 3
#define INTERRUPT_PIN 2
#define WAVELENGTH 125 // # of steps peak-to-peak 
#define MAXBRIGHT 255  // maximum brightness level (min is 0)
#define DELAY_MS 50   // delay before updating colors, in ms
#define SCALING_FACTOR 20 //THe phase distance in waveform between the each LED


/*
  we're going to use a triangle wave that's truncated below 0, like so:
  MAX |\                  /\
      | \                /  \
      |  \              /    \
      |   \            /      \
  0___|____\__________/________\_
      |

  but then overlay 3 of these, one each for R, G, B:
      R    G    B         R    G
  MAX |\   /\   /\  oops  /\   /\
      | \ /  \ /  \      /  \ /
      |  X    X    \    /    X
      | / \  / \    \  /    / \
  0___|/___\/___\____\/____/___\_
      |

  so really we want to cut off half of the negative (zero) part of the cycle:
  MAX |\             /\
      | \           /  \
      |  \         /    \
      |   \       /      \
  0___|____\_____/________\_
      |

  for this pattern:
      R    G    B    R    G    B
  MAX |\   /\   /\   /\   /\   /\
      | \ /  \ /  \ /  \ /  \ /
      |  X    X    X    X    X
      | / \  / \  / \  / \  / \
  0___|/___\/___\/___\/___\/___\/_
      |

  so, using WAVELENGTH and MAXBRIGHT, we precalculate an array of values sampled
  from the conceptual (dis)continuous function, then shift along those at each
  step, with a different offset for each color
*/

CRGB leds[NUM_LEDS];
int Ridx;
int Gidx;
int Bidx;
int tempRidx;
int tempGidx;
int tempBidx;
unsigned long prevMsB = 0;
unsigned long prevMsL = 0;
const long powerTime = 100;
const int buttonPin = 8;  // the number of the pushbutton pin

bool lightsOn = 1; //default on
bool buttPush = 0; //default off
bool changeState = 0;

byte waveform[WAVELENGTH];


void setup() {
  pinMode(buttonPin, INPUT);
  Serial.begin(9600);
  Serial.println("Hi");
  FastLED.addLeds<WS2811, DATA_PIN>(leds, NUM_LEDS);



  
  // TODO: delete most of this code by using the FastLED triwave8() func
  //       also look into other provided funcs
  //       (maybe beatsin8 would be even better?)

  /*
    start moving upward from the wave minimum, so we're going to generate this:
    MAX |     /\
        |    /  \
    0___|___/____\_
  */

  double slope = (double) (MAXBRIGHT) / (WAVELENGTH / 3);
  double val = -1 * MAXBRIGHT;
  //Serial.print("slope = "); Serial.println(slope);
  for (int i=0; i < WAVELENGTH; i++) {
    // TODO: probably going to be some errors in here
    // wrt int -> double -> int conversion
    
    // clamp to 0 while val is negative
    if (val >= 0) {
      waveform[i] = floor(val);
    } else {
      waveform[i] = 0;
    }

    val = val + slope;

    // once we hit max, start going down
    if (val >= MAXBRIGHT) {
      val = MAXBRIGHT;
      slope *= -1;
    }
    //Serial.print("i: "); Serial.print(i); Serial.print(" = "); Serial.println(val);
  }
  // these offsets will make the cycle start at 100% red,
  // as in the diagram above
  Ridx = (2 * WAVELENGTH) / 3;
  Gidx = WAVELENGTH / 3;
  Bidx = 0;
}

void loop() {
  //take time measurement
  //decide whether to do lights on or off
  
  unsigned long currMs = millis();
  unsigned int buttonState = digitalRead(buttonPin);
  if (buttonState) {
    if (!buttPush ) {
      buttPush = 1;
      prevMsB = currMs;
    }
    if (!changeState && currMs - prevMsB >= powerTime) {
      lightsOn = !lightsOn;
      changeState = 1;
    }

/*
    Serial.print("BUTTON - ");
    Serial.print(buttPush);
    Serial.print("\t");
    Serial.print(changeState);
    Serial.print("\t");
    Serial.print(prevMsB);
    Serial.print("\t");
    Serial.print(currMs);
    Serial.print("\n");
*/

  } else {
  /*  if(buttPush) {
      Serial.println("BUTTON OFF ----------------------------------");
    }*/
    buttPush = 0;
    changeState = 0;
  }
  
  if (currMs - prevMsL >= DELAY_MS) {
    prevMsL = currMs;
    if (lightsOn) {
      lightsCycle();
      //Serial.print("ON:  ");
      //Serial.println(currMs);
    } else {
      lightsOff();
      //Serial.print("OFF: ");
      //Serial.println(currMs);
    }
    
  }
  delay(10);
}

void lightsOff() {
  for (int i = 0; i < NUM_LEDS; i++) {
      leds[i].setRGB(0,0,0);
  }
 
  FastLED.show();
}

void lightsCycle() {
  
    // scan through the full waveform to assign a different value
    // to each LED, looping back to the start as necessary
    for(int n=0; n < NUM_LEDS; n++) {

      tempRidx = (Ridx + n*SCALING_FACTOR) % WAVELENGTH;
      tempGidx = (Gidx + n*SCALING_FACTOR) % WAVELENGTH;
      tempBidx = (Bidx + n*SCALING_FACTOR) % WAVELENGTH;


      leds[n].r = waveform[tempRidx];
      leds[n].g = waveform[tempGidx];
      leds[n].b = waveform[tempBidx];
    }

    Ridx = (Ridx + 1) % WAVELENGTH;
    Gidx = (Gidx + 1) % WAVELENGTH;
    Bidx = (Bidx + 1) % WAVELENGTH;
 

  FastLED.show();
  delay(DELAY_MS);
}

